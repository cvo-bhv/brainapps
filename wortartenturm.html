import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, Clock, Trophy, RefreshCcw, Settings, User, Users, Volume2, VolumeX, Wand2, Loader, Mic, Flame } from 'lucide-react';

// --- API CONFIGURATION ---
const apiKey = ""; // Wird zur Laufzeit bereitgestellt

// --- FONTS & GLOBAL STYLES ---
const PixelFontStyles = () => (
  <style>{`
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
    
    .font-pixel {
      font-family: 'VT323', monospace;
    }

    .pixel-shadow {
      box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
    }
    
    .pixel-border {
      box-shadow: 
        inset 2px 2px 0px rgba(255,255,255,0.4),
        inset -2px -2px 0px rgba(0,0,0,0.4);
    }

    /* 3D CUBE STYLES */
    .scene-container {
      perspective: 1000px;
      overflow: hidden;
    }
    
    .world {
      transform-style: preserve-3d;
      transform: rotateX(10deg);
      height: 100%;
    }

    .cube {
      position: relative;
      width: 100%;
      height: 48px;
      transform-style: preserve-3d;
      transition: transform 0.3s;
    }

    .face {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
    }

    .face.front {
      width: 100%;
      height: 48px;
      transform: translateZ(24px);
    }

    .face.top {
      width: 100%;
      height: 48px;
      transform: rotateX(90deg) translateZ(24px);
      filter: brightness(1.2);
    }

    .face.right {
      width: 48px;
      height: 48px;
      right: 0;
      transform: rotateY(90deg) translateZ(24px); 
      filter: brightness(0.8);
      right: -24px;
      position: absolute; 
    }
    
    .face.left {
      width: 48px;
      height: 48px;
      left: -24px;
      transform: rotateY(-90deg) translateZ(24px);
      filter: brightness(0.8);
    }

    @keyframes floatCloud {
      0% { transform: translateX(100vw); }
      100% { transform: translateX(-200px); }
    }
    
    .mc-btn:active {
      transform: translateY(4px);
      box-shadow: 0px 0px 0px rgba(0,0,0,0.5) !important;
    }
    
    @keyframes popIn {
      0% { transform: scale(0); opacity: 0; }
      80% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
  `}</style>
);

// --- GEMINI API HELPERS ---
const generateGeminiHint = async (word) => {
  if (!apiKey) return "Kein API Key verfÃ¼gbar.";
  const prompt = `Du bist ein lustiger Roboter in einem Lernspiel fÃ¼r Kinder. Gib einen kurzen, einfachen Hinweis zum deutschen Wort "${word}", damit das Kind erraten kann, ob es ein Nomen, Verb oder Adjektiv ist. Verrate NICHT die Wortart direkt und nenne NICHT das Wort selbst! Antworte mit maximal einem Satz.`;
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });
    if (!response.ok) throw new Error('API Error');
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || "Konnte keinen Hinweis laden.";
  } catch (error) {
    console.error(error);
    return "Der Roboter schlÃ¤ft gerade...";
  }
};

const playGeminiTTS = async (text) => {
  if (!apiKey) return;
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: text }] }],
        generationConfig: {
          responseModalities: ["AUDIO"],
          speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
        }
      })
    });
    if (!response.ok) throw new Error('TTS Error');
    const data = await response.json();
    const audioContent = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
    if (audioContent) {
      const binaryString = window.atob(audioContent);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
      const ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
      const audioBuffer = await ctx.decodeAudioData(bytes.buffer.slice(0)); 
      const source = ctx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(ctx.destination);
      source.start(0);
    }
  } catch (error) {
    console.error("TTS failed:", error);
  }
};

// --- SOUND ENGINE ---
const createSoundEngine = () => {
  if (typeof window === 'undefined') return null;
  const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
  if (!AudioContext) return null;
  const ctx = new AudioContext();

  const playOsc = (freq, type, duration, startTime = 0, vol = 0.1) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, ctx.currentTime + startTime);
    gain.gain.setValueAtTime(vol, ctx.currentTime + startTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + startTime + duration);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime + startTime);
    osc.stop(ctx.currentTime + startTime + duration);
  };

  return {
    playCorrect: () => { playOsc(987, 'square', 0.1, 0, 0.1); playOsc(1318, 'square', 0.3, 0.1, 0.1); },
    playWrong: () => { playOsc(150, 'sawtooth', 0.15, 0, 0.2); playOsc(100, 'sawtooth', 0.3, 0.1, 0.2); },
    playTick: () => playOsc(800, 'square', 0.05, 0, 0.05),
    playCrane: () => { playOsc(100, 'square', 0.1, 0, 0.05); playOsc(80, 'square', 0.1, 0.1, 0.05); },
    playWin: () => { [523, 659, 783, 1046, 783, 1046].forEach((f, i) => playOsc(f, 'square', 0.2, i * 0.15, 0.1)); },
    playPop: () => playOsc(400, 'square', 0.1, 0, 0.1),
    playLava: () => { playOsc(100, 'sawtooth', 0.5, 0, 0.1); playOsc(50, 'sawtooth', 0.5, 0.1, 0.1); },
    resume: () => { if (ctx.state === 'suspended') ctx.resume(); }
  };
};

// --- DATA ---
const WORD_DATA = {
  Nomen: [
    "Auto", "Buch", "Essen", "Geld", "Geschenk", "Haus", "Jahr", "Kind", "Leben", "Licht", 
    "Wasser", "Freund", "Hund", "Mensch", "SchlÃ¼ssel", "Stuhl", "Familie", "Freiheit", 
    "Mutter", "Reise", "Schule", "Stadt", "StraÃŸe", "Zeit", "Sonne", "Mond", "Tisch", "Fenster"
  ],
  Verben: [
    "laufen", "gehen", "aufstehen", "radfahren", "rutschen", "schaukeln", "schleichen", 
    "schwimmen", "springen", "turnen", "denken", "flÃ¼stern", "hÃ¶ren", "jubeln", "klatschen", 
    "lachen", "schreien", "singen", "sprechen", "telefonieren", "helfen", "geben", "nehmen", 
    "spielen", "streicheln", "umarmen", "trÃ¤umen", "schieben", "tragen", "ziehen", "backen", 
    "essen", "kochen", "trinken", "schlafen", "malen", "schreiben", "suchen", "hinsetzen",
    "aufwachen", "duschen", "kÃ¤mmen", "waschen", "ZÃ¤hne putzen", "schneiden", "melden"
  ],
  Adjektive: [
    "altmodisch", "modern", "alt", "jung", "neu", "angenehm", "unangenehm", "bekannt", 
    "unbekannt", "bequem", "unbequem", "breit", "eng", "bunt", "schwarz-weiÃŸ", "dick", "dÃ¼nn", 
    "eckig", "rund", "erster", "letzter", "frei", "besetzt", "freundlich", "unfreundlich", 
    "frÃ¶hlich", "traurig", "froh", "sauer", "frÃ¼h", "spÃ¤t", "gefÃ¤hrlich", "ungefÃ¤hrlich", 
    "gemÃ¼tlich", "ungemÃ¼tlich", "gesund", "krank", "ungesund", "glÃ¼cklich", "unglÃ¼cklich", 
    "gut", "schlecht", "groÃŸ", "klein", "viel", "wenig", "laut", "leise", "schwer", "leicht", 
    "richtig", "falsch", "schÃ¶n", "hÃ¤sslich", "ganz", "kaputt", "lang", "kurz", "nett", 
    "normal", "offen", "geschlossen", "stark", "schwach", "voll", "leer", "warm", "kÃ¼hl", 
    "weit", "nah", "heiÃŸ", "kalt", "interessant", "langweilig", "mÃ¶glich", "unmÃ¶glich", 
    "mÃ¼de", "ausgeschlafen", "schnell", "langsam", "teuer", "billig", "wichtig", "unwichtig", 
    "anwesend", "abwesend", "ehrlich", "unehrlich", "hÃ¶flich", "unhÃ¶flich", "nackt", 
    "bekleidet", "natÃ¼rlich", "unnatÃ¼rlich", "ordentlich", "unordentlich", "positiv", 
    "negativ", "sicher", "unsicher", "vorsichtig", "unvorsichtig", "optimistisch", 
    "pessimistisch", "scharf", "sonnig", "wolkig", "sportlich", "unsportlich"
  ]
};

const TOTAL_WORDS = WORD_DATA.Nomen.length + WORD_DATA.Verben.length + WORD_DATA.Adjektive.length;
const TEAM_NAMES = ["Die Pixel-Piloten", "Block-Baumeister", "Crafting-Champions", "Voxel-Vulkane", "Redstone-Ritter", "Die Creeper-JÃ¤ger"];

const BLOCK_THEMES = {
  Nomen: { face: 'bg-[#64ddbd]', border: 'border-[#2ac7a3]', top: 'bg-[#8cf4d8]', text: 'text-[#0f5244]' },
  Verben: { face: 'bg-[#d12f2f]', border: 'border-[#8f1e1e]', top: 'bg-[#e85656]', text: 'text-[#4a0d0d]' },
  Adjektive: { face: 'bg-[#2bba45]', border: 'border-[#1b7a2d]', top: 'bg-[#4cdb68]', text: 'text-[#0e3b16]' },
  Neutral: { face: 'bg-[#7d7d7d]', border: 'border-[#555555]', top: 'bg-[#9e9e9e]', text: 'text-[#333333]' }
};

const getUniqueWord = (usedWordsList) => {
  const candidates = [];
  Object.keys(WORD_DATA).forEach(type => {
    WORD_DATA[type].forEach(word => {
      if (!usedWordsList.includes(word)) candidates.push({ word, type });
    });
  });
  if (candidates.length === 0) return null; 
  return candidates[Math.floor(Math.random() * candidates.length)];
};

const getFontSizeStyle = (word, context) => {
  const len = word ? word.length : 0;
  if (context === 'crane') {
    if (len > 18) return { fontSize: '1.2rem', lineHeight: '1.2rem', letterSpacing: '-1px' };
    if (len > 14) return { fontSize: '1.5rem', lineHeight: '1.5rem' };
    return { fontSize: '2rem', lineHeight: '2rem' }; 
  } 
  if (len > 18) return { fontSize: '0.8rem', lineHeight: '1rem', letterSpacing: '-1px' }; 
  if (len > 14) return { fontSize: '0.9rem', lineHeight: '1rem', letterSpacing: '-0.5px' };
  if (len > 12) return { fontSize: '1rem', lineHeight: '1.1rem' };
  return { fontSize: '1.2rem', lineHeight: '1.2rem' }; 
};

// --- 3D COMPONENTS ---

const Cube = ({ type, word, isCrane = false }) => {
  const theme = BLOCK_THEMES[type] || BLOCK_THEMES.Neutral;
  const style = getFontSizeStyle(word, isCrane ? 'crane' : 'tower');

  return (
    <div className="cube w-full">
      <div className={`face front ${theme.face} border-4 ${theme.border} pixel-border flex items-center justify-center`}>
        <span className={`font-pixel font-bold uppercase text-center w-full px-1 ${theme.text}`} style={style}>{word}</span>
        <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'radial-gradient(circle, #000 1px, transparent 1px)', backgroundSize: '4px 4px'}}></div>
      </div>
      <div className={`face top ${theme.top} border-4 ${theme.border}`}>
        <div className="absolute inset-0 opacity-10" style={{backgroundImage: 'radial-gradient(circle, #fff 1px, transparent 1px)', backgroundSize: '4px 4px'}}></div>
      </div>
      {!isCrane && (
        <div className={`face right ${theme.face} border-4 ${theme.border} w-[24px]`}></div>
      )}
    </div>
  );
};

const MinecraftBackground = ({ theme = 'normal' }) => {
  const isNether = theme === 'nether';
  
  return (
    <div className={`absolute inset-0 z-0 overflow-hidden transition-colors duration-1000 ${isNether ? 'bg-[#2a0e0e]' : 'bg-[#87CEEB]'}`}>
      {isNether ? (
        <>
          <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'radial-gradient(circle, #500 2px, transparent 2px)', backgroundSize: '32px 32px'}}></div>
          <div className="absolute bottom-20 w-full h-40 opacity-50 bg-orange-600 blur-xl animate-pulse"></div>
        </>
      ) : (
        <>
          <div className="absolute top-10 right-10 w-24 h-24 bg-[#fff133] border-4 border-[#e6d82e] shadow-[8px_8px_0px_rgba(0,0,0,0.2)]"></div>
          {[1, 2, 3].map(i => (
            <div key={i} className="absolute h-16 bg-white opacity-80 border-4 border-white/50" 
                 style={{
                   width: `${100 + i * 50}px`,
                   top: `${i * 15}%`,
                   animation: `floatCloud ${20 + i * 10}s linear infinite`,
                   boxShadow: '8px 8px 0px rgba(0,0,0,0.1)'
                 }}></div>
          ))}
        </>
      )}
  
      <div className="absolute bottom-0 w-full h-32 z-10">
         <div className={`w-full h-8 border-t-4 relative ${isNether ? 'bg-[#8B0000] border-[#5e0000]' : 'bg-[#5baf38] border-[#76d14d]'}`}>
            {isNether ? (
               <div className="absolute inset-0 opacity-40" style={{backgroundImage: 'repeating-linear-gradient(45deg, #ff4500, #ff4500 5px, #8b0000 5px, #8b0000 15px)'}}></div>
            ) : (
               <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'repeating-linear-gradient(45deg, transparent, transparent 10px, #4a912d 10px, #4a912d 20px)'}}></div>
            )}
         </div>
         <div className={`w-full h-full border-t-4 ${isNether ? 'bg-[#3b1e1e] border-[#291010]' : 'bg-[#8b5e3c] border-[#6d4a2f]'}`}>
            <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'radial-gradient(circle, #000 2px, transparent 2px)', backgroundSize: '16px 16px'}}></div>
         </div>
      </div>
    </div>
  );
};

// IMPROVED CRANE 3D - Now handles precise stacking
const Crane3D = ({ xPosition, towerHeight, gameState, blockVisualType, currentWord }) => {
  const isDropping = gameState === 'dropping';
  const isPlacing = gameState === 'placing'; // New state for holding bottom position
  const isRetracting = gameState === 'retracting';
  const isExploding = gameState === 'exploding';

  if (isExploding) return null;

  // CONSTANTS FOR MATH
  const PADDING_BOTTOM = 128; // pb-32
  const BASE_HEIGHT = 32;     // h-8
  const CRANE_TOP_OFFSET = 80;// Top-20 (80px)
  const BLOCK_HEIGHT = 48;
  const PISTON_HEAD_HEIGHT = 16; // 4px border + 4px div... approx visual

  // Calculate precise piston length to touch top of stack
  // Screen Height = 100vh
  // Stack Top from Bottom = 128 + 32 + (Blocks * 48)
  // Stack Top from Top = 100vh - (160 + Blocks*48)
  // Piston Start from Top = 80px
  // Block hangs below piston arm. Visual Block Height = 48px.
  // We want Block Bottom to be at Stack Top.
  // Block Top = Stack Top + 48px (Wait, Y goes down). 
  // Actually in CSS: Top 0 is top.
  // Stack Top (Y) = 100vh - (128 + 32 + Blocks*48).
  // Block Bottom (Y) = Stack Top (Y).
  // Block Top (Y) = Block Bottom (Y) - 48.
  // Piston End (Y) = Block Top (Y).
  // Piston Length = Piston End (Y) - Piston Start (Y)
  // Length = (100vh - (160 + Blocks*48) - 48) - 80.
  // Length = 100vh - 288 - Blocks*48.
  
  // Correction: The block is rendered `transform translate-y-full` relative to the arm bottom.
  // So visual bottom of block is ArmLength + 48px below the start of arm? 
  // Piston Arm container has `top: 20` (80px).
  // Inside it: `h-full` (dynamic).
  // At bottom: Block container.
  // So visual bottom of block = 80 + length + 48.
  // We want visual bottom = 100vh - (128 + 32 + towerHeight*48).
  
  // So: 80 + L + 48 = 100vh - (160 + towerHeight*48).
  // L = 100vh - 160 - 48 - 80 - towerHeight*48
  // L = 100vh - 288 - towerHeight*48.

  const pistonLengthCalc = `calc(100vh - ${288 + (towerHeight * 48)}px)`;

  return (
    <div 
      className="absolute top-0 bottom-0 pointer-events-none z-30 transition-all duration-1000 ease-in-out"
      style={{ left: xPosition, transform: 'translateX(-50%)', width: '160px' }}
    >
      <div className="absolute top-0 left-1/2 transform -translate-x-1/2 w-32 h-20 bg-[#9c9c9c] border-x-4 border-b-4 border-[#6e6e6e] z-30 shadow-[8px_8px_0px_rgba(0,0,0,0.3)] flex flex-col items-center justify-center">
         <div className="w-full h-2 bg-[#757575] mb-2"></div>
         <div className="w-24 h-12 bg-[#b8b8b8] border-4 border-[#808080] flex items-center justify-center">
            <div className="w-4 h-4 bg-red-500 animate-pulse shadow-[0_0_10px_red]"></div>
         </div>
      </div>
      <div 
        className="absolute top-20 left-1/2 transform -translate-x-1/2 w-8 bg-[#8f6d45] border-x-4 border-[#5c462c] flex flex-col items-center transition-all ease-linear"
        style={{ 
          height: (isDropping || isPlacing) ? pistonLengthCalc : '80px', 
          transitionDuration: isDropping ? '700ms' : (isPlacing ? '0ms' : '700ms'),
          transitionTimingFunction: isDropping ? 'cubic-bezier(0.5, 0, 1, 1)' : 'ease-out',
          backgroundImage: 'repeating-linear-gradient(0deg, #8f6d45, #8f6d45 10px, #7a5d3b 10px, #7a5d3b 20px)'
        }}
      >
        {/* Render block only if not retracting (so it stays during dropping AND placing) */}
        {!isRetracting && (
          <div className="absolute bottom-0 transform translate-y-full w-40">
             <div className="w-full h-4 bg-[#8b5e3c] border-4 border-[#5c462c] mb-[-4px] relative z-20"></div>
             <div className="relative z-30 transform translate-y-2">
               <Cube type={blockVisualType} word={currentWord} isCrane={true} />
             </div>
          </div>
        )}
      </div>
    </div>
  );
};

const ExplosionParticles = ({ active, type = 'normal' }) => {
  if (!active) return null;
  const isLava = type === 'lava';
  
  return (
    <div className="absolute top-1/3 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none w-64 h-64">
       {[...Array(20)].map((_, i) => (
         <div 
           key={i}
           className={`absolute w-4 h-4 border-2 border-black ${isLava ? 'bg-orange-500' : 'bg-gray-800'}`}
           style={{
             left: '50%', top: '50%',
             animation: `particleFly ${0.5 + Math.random() * 0.5}s ease-out forwards`,
             animationDelay: `${Math.random() * 0.1}s`,
             '--tx': `${(Math.random() - 0.5) * 300}px`,
             '--ty': `${(Math.random() - 0.5) * 300}px`,
             '--r': `${Math.random() * 720}deg`
           }}
         ></div>
       ))}
       <style>{`
         @keyframes particleFly {
           0% { transform: translate(0,0) rotate(0deg) scale(1); opacity: 1; }
           100% { transform: translate(var(--tx), var(--ty)) rotate(var(--r)) scale(0); opacity: 0; }
         }
       `}</style>
       <div className="absolute inset-0 flex items-center justify-center">
         <div className={`font-pixel text-6xl drop-shadow-[4px_4px_0_#000] animate-bounce ${isLava ? 'text-orange-500' : 'text-red-600'}`}>
           {isLava ? 'LAVA!' : 'BOOM!'}
         </div>
       </div>
    </div>
  );
};

const HintBubble = ({ text, onClose }) => (
  <div 
    className="absolute top-24 left-1/2 transform -translate-x-1/2 z-50 max-w-sm w-full p-4 animate-[popIn_0.4s_ease-out]"
    onClick={onClose}
  >
    <div className="bg-[#fff] border-4 border-black p-4 relative shadow-[8px_8px_0_rgba(0,0,0,0.5)]">
      <div className="text-xl text-black font-pixel leading-tight">{text}</div>
      <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-[16px] border-l-transparent border-r-[16px] border-r-transparent border-t-[16px] border-t-black"></div>
      <div className="absolute -bottom-[10px] left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-[12px] border-l-transparent border-r-[12px] border-r-transparent border-t-[12px] border-t-white"></div>
    </div>
    <div className="text-center mt-6">
       <div className="inline-block bg-[#87CEEB] border-4 border-black rounded-full p-2">
         <span className="text-2xl">ðŸ¤–</span>
       </div>
    </div>
  </div>
);

// --- SCREENS ---

const SetupScreen = ({ onStart, onUpdateMode, onUpdateTeams, onUpdateNames, onUpdateTheme, mode, numTeams, names, theme, isMuted, toggleMute }) => (
  <div className={`min-h-screen flex items-center justify-center p-4 relative font-pixel transition-colors duration-500 ${theme === 'nether' ? 'bg-[#2a0e0e]' : 'bg-[#4a3b32]'}`}>
    <div className="absolute inset-0 opacity-10" style={{backgroundImage: 'radial-gradient(#6d4a2f 2px, transparent 2px)', backgroundSize: '16px 16px'}}></div>
    
    <div className="max-w-3xl w-full bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] shadow-[10px_10px_0px_rgba(0,0,0,0.5)] relative z-10 p-2">
      <div className={`p-8 text-center border-4 border-[#555] border-b-white border-r-white mb-4 ${theme === 'nether' ? 'bg-[#8b0000]' : 'bg-[#8b8b8b]'}`}>
        <h1 className="text-6xl text-[#ffff55] drop-shadow-[4px_4px_0_#3f3f3f] uppercase tracking-widest mb-2">
          Turmbau
        </h1>
        <div className="text-xl text-white uppercase tracking-widest">{theme === 'nether' ? 'ðŸ”¥ LAVA EDITION ðŸ”¥' : 'Wortarten Edition'}</div>
      </div>

      <div className="p-6 space-y-6">
        <button onClick={toggleMute} className="absolute top-6 right-6 p-2 bg-[#c6c6c6] border-2 border-white border-b-[#555] border-r-[#555] active:border-t-[#555] active:border-l-[#555] active:border-b-white active:border-r-white">
          {isMuted ? <VolumeX size={24} /> : <Volume2 size={24} />}
        </button>

        <div>
          <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Welt WÃ¤hlen</label>
          <div className="flex gap-4">
            <button onClick={() => onUpdateTheme('normal')} className={`flex-1 py-4 text-2xl uppercase border-4 transition-transform mc-btn ${theme === 'normal' ? 'bg-[#5baf38] text-white border-[#3c7a22] border-t-[#76d14d]' : 'bg-[#c6c6c6] text-gray-600 border-[#7d7d7d]'}`}>
               ðŸŒ² Grasland
            </button>
            <button onClick={() => onUpdateTheme('nether')} className={`flex-1 py-4 text-2xl uppercase border-4 transition-transform mc-btn ${theme === 'nether' ? 'bg-[#d12f2f] text-white border-[#8f1e1e] border-t-[#e85656]' : 'bg-[#c6c6c6] text-gray-600 border-[#7d7d7d]'}`}>
               ðŸ”¥ Lava-Welt
            </button>
          </div>
          {theme === 'nether' && <div className="text-red-800 mt-1 text-lg">Warnung: Falsche Antworten zerstÃ¶ren deinen Turm!</div>}
        </div>

        <div>
          <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Spielmodus</label>
          <div className="flex gap-4">
            <button onClick={() => onUpdateMode('teams')} className={`flex-1 py-4 text-2xl uppercase border-4 transition-transform mc-btn ${mode === 'teams' ? 'bg-[#2a7fff] text-white border-[#1a4f9e]' : 'bg-[#c6c6c6] text-gray-600 border-[#7d7d7d]'}`}>
               <Users className="inline mr-2" /> Teams
            </button>
            <button onClick={() => onUpdateMode('ffa')} className={`flex-1 py-4 text-2xl uppercase border-4 transition-transform mc-btn ${mode === 'ffa' ? 'bg-[#2a7fff] text-white border-[#1a4f9e]' : 'bg-[#c6c6c6] text-gray-600 border-[#7d7d7d]'}`}>
               <User className="inline mr-2" /> Solo
            </button>
          </div>
        </div>

        {mode === 'teams' && (
          <div>
            <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Anzahl Teams</label>
            <div className="flex gap-2">
              {[2, 3, 4, 5].map(num => (
                <button key={num} onClick={() => onUpdateTeams(num)} className={`flex-1 py-2 text-2xl border-4 mc-btn ${numTeams === num ? 'bg-[#ffff55] text-black border-[#baba3e]' : 'bg-[#c6c6c6] text-gray-500 border-[#7d7d7d]'}`}>
                  {num}
                </button>
              ))}
            </div>
          </div>
        )}

        <div>
           <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Namen (Komma getrennt)</label>
           <textarea 
             value={names}
             onChange={(e) => onUpdateNames(e.target.value)}
             className="w-full p-4 bg-black text-white font-pixel text-xl border-4 border-[#7d7d7d] shadow-[inset_4px_4px_0_rgba(0,0,0,0.5)] focus:outline-none"
             rows={3}
             placeholder="Steve, Alex, Zombie..."
           />
        </div>

        <button onClick={onStart} className="w-full py-6 bg-[#5baf38] text-white text-4xl uppercase border-4 border-[#3c7a22] border-t-[#76d14d] shadow-[4px_4px_0_#285217] mc-btn active:translate-y-1">
           Spiel Starten
        </button>
      </div>
    </div>
  </div>
);

const GameScreen = ({ teams, currentTeamIndex, currentWordObj, timeLeft, feedback, gameState, craneTarget, blockVisualType, usedCount, isMuted, toggleMute, onAnswer, onRestart, isCrowded, teamRefs, containerRef, shake, onGetHint, hintText, isHintLoading, onTTS, isSpeaking, theme }) => (
  <div className={`min-h-screen overflow-hidden relative font-pixel select-none ${shake ? 'animate-[shake_0.5s_ease-in-out_infinite]' : ''}`}>
    <style>{`
       @keyframes shake {
         0%, 100% { transform: translateX(0); }
         25% { transform: translateX(-8px) rotate(-1deg); }
         75% { transform: translateX(8px) rotate(1deg); }
       }
    `}</style>

    <MinecraftBackground theme={theme} />

    {/* HUD Top Bar */}
    <div className="absolute top-0 w-full p-4 z-40 flex justify-between items-start pointer-events-none">
       {/* Round Info */}
       <div className="pointer-events-auto bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 min-w-[100px] text-center shadow-lg">
          <div className="text-gray-600 text-sm uppercase">Runde</div>
          <div className="text-3xl text-black">{Math.floor(teams.reduce((acc, t) => acc + t.tower.length, 0) / teams.length) + 1}</div>
       </div>

       {/* Active Team Banner */}
       <div className="pointer-events-auto transform translate-y-4">
          <div className={`border-4 border-white border-b-[#555] border-r-[#555] px-8 py-2 shadow-xl flex flex-col items-center ${theme === 'nether' ? 'bg-[#8b0000] text-white' : 'bg-[#c6c6c6] text-black'}`}>
             <div className={`text-xs uppercase mb-1 ${theme === 'nether' ? 'text-red-200' : 'text-gray-600'}`}>Am Zug</div>
             <div className="text-3xl uppercase">{teams[currentTeamIndex].name}</div>
          </div>
       </div>

       {/* Tools */}
       <div className="pointer-events-auto flex gap-2">
          {/* GEMINI HINT BUTTON */}
          <button 
             onClick={onGetHint} 
             disabled={isHintLoading || gameState !== 'waiting'}
             className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 hover:bg-[#dcdcdc] mc-btn group relative"
             title="Magischer Hinweis (Gemini)"
          >
             {isHintLoading ? <Loader className="animate-spin text-[#d12f2f]" /> : <Wand2 className="text-[#9d4dcc]" />}
             <div className="absolute -top-1 -right-1 text-xs animate-bounce">âœ¨</div>
          </button>

          {/* GEMINI TTS BUTTON */}
          <button 
             onClick={onTTS} 
             disabled={isSpeaking || gameState !== 'waiting'}
             className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 hover:bg-[#dcdcdc] mc-btn"
             title="Vorlesen (Gemini TTS)"
          >
             <Volume2 className={isSpeaking ? "text-[#5baf38]" : "text-black"} />
          </button>
          
          <div className="w-2"></div>

          <div className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 text-center">
             <div className="text-xs text-gray-600 uppercase">WÃ¶rter</div>
             <div className="text-xl text-black">{usedCount} / {TOTAL_WORDS}</div>
          </div>
          <button onClick={toggleMute} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 hover:bg-[#dcdcdc] mc-btn">
             {isMuted ? <VolumeX /> : <Volume2 className="opacity-50" />}
          </button>
          <button onClick={onRestart} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 hover:bg-[#dcdcdc] mc-btn">
             <RefreshCcw />
          </button>
       </div>
    </div>

    {/* GAME SCENE */}
    <div className="flex-1 absolute inset-0 pt-32 pb-32 flex flex-col scene-container">
      
      {hintText && <HintBubble text={hintText} onClose={onGetHint} />}

      {currentWordObj && (
        <Crane3D 
           xPosition={craneTarget}
           // Pass the specific tower length for this team
           towerHeight={teams[currentTeamIndex].tower.length}
           gameState={gameState}
           blockVisualType={blockVisualType}
           currentWord={currentWordObj.word}
        />
      )}

      {/* Explosion Effects */}
      {gameState === 'exploding' && <ExplosionParticles active={true} type={theme === 'nether' ? 'lava' : 'normal'} />}

      {/* Feedback Text */}
      {feedback && feedback !== 'wrong' && (
         <div className="absolute top-1/3 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50">
            <h1 className="text-6xl text-[#ffff55] drop-shadow-[6px_6px_0_#3f3f3f] animate-bounce uppercase">
              Richtig!
            </h1>
         </div>
      )}

      {/* Towers Container */}
      <div 
         ref={containerRef}
         className={`flex-1 flex items-end px-8 z-10 w-full relative world ${isCrowded ? 'overflow-x-auto justify-start gap-8' : 'justify-around'}`}
      >
         {teams.map((team, idx) => {
           const isActive = idx === currentTeamIndex;
           return (
             <div 
               key={team.id}
               ref={el => teamRefs.current[idx] = el}
               className={`flex flex-col items-center justify-end h-full transition-opacity duration-300 ${isCrowded && !isActive ? 'opacity-80' : 'opacity-100'}`}
               style={{ width: isCrowded ? '160px' : `${100/teams.length}%`, minWidth: isCrowded ? '160px' : 'auto' }}
             >
                {/* Active Marker */}
                {isActive && <div className="animate-bounce mb-4 text-4xl text-[#ffff55] drop-shadow-[4px_4px_0_#000]">â–¼</div>}

                {/* The Tower Stack */}
                <div className="flex flex-col-reverse items-center w-full max-w-[140px] perspective-[500px]">
                   {/* Base Block */}
                   <div className="w-full h-8 bg-[#222] border-4 border-black relative"></div>
                   
                   {/* Stacked Blocks */}
                   {team.tower.map((block, bIdx) => (
                      <Cube key={bIdx} type={block.type} word={block.word} />
                   ))}
                </div>

                {/* Team Name Sign */}
                <div className="mt-4 bg-[#b68962] border-4 border-[#5c4033] px-4 py-2 text-center shadow-lg transform rotate-x-12">
                   <div className="text-white drop-shadow-md uppercase text-sm">{team.name}</div>
                </div>
             </div>
           );
         })}
         {isCrowded && <div className="w-8 shrink-0"></div>}
      </div>
    </div>

    {/* CONTROLS (Bottom) */}
    <div className={`absolute bottom-0 w-full border-t-8 border-black p-4 z-50 ${theme === 'nether' ? 'bg-[#2b0505]' : 'bg-[#333]'}`}>
       {/* XP Bar for Time */}
       <div className="absolute top-0 left-0 w-full h-4 bg-[#111]">
          <div className={`h-full shadow-[inset_0_2px_0_rgba(255,255,255,0.5)] transition-all duration-1000 linear ${theme === 'nether' ? 'bg-orange-500' : 'bg-[#80ff20]'}`} style={{ width: `${(timeLeft / 20) * 100}%` }}></div>
       </div>

       <div className="max-w-4xl mx-auto flex gap-4 mt-4">
          {/* Time Counter */}
          <div className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 min-w-[80px] flex items-center justify-center">
             <span className={`text-4xl ${timeLeft < 6 ? 'text-red-600 animate-pulse' : 'text-black'}`}>{timeLeft}</span>
          </div>

          {/* Action Buttons */}
          {['Nomen', 'Verben', 'Adjektive'].map(type => {
             const _theme = BLOCK_THEMES[type];
             return (
               <button 
                 key={type}
                 disabled={gameState !== 'waiting'}
                 onClick={() => onAnswer(type)}
                 className={`flex-1 h-20 border-4 border-b-8 active:border-b-4 active:translate-y-1 active:border-t-8 transition-all disabled:opacity-50 disabled:grayscale uppercase text-3xl text-white shadow-lg mc-btn
                   ${type === 'Nomen' ? 'bg-[#64ddbd] border-[#2ac7a3] border-t-[#8cf4d8] text-[#0f5244]' : ''}
                   ${type === 'Verben' ? 'bg-[#d12f2f] border-[#8f1e1e] border-t-[#e85656] text-[#4a0d0d]' : ''}
                   ${type === 'Adjektive' ? 'bg-[#2bba45] border-[#1b7a2d] border-t-[#4cdb68] text-[#0e3b16]' : ''}
                 `}
               >
                 {type}
               </button>
             );
          })}
       </div>
    </div>
  </div>
);

const SummaryScreen = ({ teams, onRestart, playSound, theme }) => {
   const maxHeight = Math.max(...teams.map(t => t.tower.length));
   
   useEffect(() => {
     if(playSound) playSound.playWin();
   }, [playSound]);
 
   return (
     <div className={`min-h-screen flex flex-col items-center justify-center p-4 relative font-pixel ${theme === 'nether' ? 'bg-[#2a0e0e]' : 'bg-[#4a3b32]'}`}>
        <div className="absolute inset-0 opacity-10" style={{backgroundImage: 'radial-gradient(#6d4a2f 2px, transparent 2px)', backgroundSize: '16px 16px'}}></div>
        
        <div className="z-10 text-center w-full max-w-7xl">
           <h1 className="text-8xl text-[#ffff55] drop-shadow-[8px_8px_0_#3f3f3f] mb-8 uppercase animate-bounce">
              Spiel Ende
           </h1>
           
           <div className="flex flex-wrap justify-center gap-8 items-end mb-16 overflow-x-auto p-8">
             {teams.map((team, idx) => {
               const isWinner = team.tower.length === maxHeight;
               return (
                 <div key={team.id} className={`flex flex-col items-center transition-all ${isWinner ? 'scale-110 z-10 -translate-y-4' : 'opacity-90'}`}>
                    {isWinner && <Trophy className="text-[#ffff55] w-24 h-24 mb-4 drop-shadow-[4px_4px_0_#000]" />}
                    <div className={`p-6 bg-[#c6c6c6] border-4 ${isWinner ? 'border-[#ffff55]' : 'border-white'} border-b-[#555] border-r-[#555] text-center shadow-xl min-w-[180px]`}>
                       <div className="text-xl uppercase mb-2">{team.name}</div>
                       <div className="text-6xl mb-2">{team.tower.length}</div>
                       <div className="text-xs uppercase text-gray-600">BlÃ¶cke</div>
                    </div>
                 </div>
               );
             })}
           </div>
 
           <button onClick={onRestart} className="py-6 px-12 bg-[#5baf38] text-white text-4xl uppercase border-4 border-[#3c7a22] border-t-[#76d14d] shadow-[4px_4px_0_#285217] mc-btn active:translate-y-1">
             Neue Runde
           </button>
        </div>
     </div>
   );
 };

// --- MAIN CONTROLLER ---

export default function WortartenSpiel3D() {
  const [phase, setPhase] = useState('setup');
  const [gameMode, setGameMode] = useState('teams');
  const [numTeams, setNumTeams] = useState(2);
  const [playerInput, setPlayerInput] = useState("");
  const [teams, setTeams] = useState([]);
  
  // New: Theme State (normal vs nether)
  const [theme, setTheme] = useState('normal'); 

  // Game State
  const [currentTeamIndex, setCurrentTeamIndex] = useState(0);
  const [currentWordObj, setCurrentWordObj] = useState(null);
  const [timeLeft, setTimeLeft] = useState(20);
  const [gameState, setGameState] = useState('waiting');
  const [feedback, setFeedback] = useState(null);
  const [craneTarget, setCraneTarget] = useState('50%');
  const [blockVisualType, setBlockVisualType] = useState('Neutral');
  const [shake, setShake] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  
  // Gemini State
  const [hintText, setHintText] = useState(null);
  const [isHintLoading, setIsHintLoading] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);

  const usedWordsRef = useRef([]);
  const [usedCount, setUsedCount] = useState(0);
  const soundEngineRef = useRef(null);
  const timerRef = useRef(null);
  const containerRef = useRef(null);
  const teamRefs = useRef([]);

  // Init Sound
  useEffect(() => { soundEngineRef.current = createSoundEngine(); }, []);
  const playSound = useCallback((name) => {
    if (!isMuted && soundEngineRef.current) {
      soundEngineRef.current.resume();
      if(name === 'correct') soundEngineRef.current.playCorrect();
      if(name === 'wrong') soundEngineRef.current.playWrong();
      if(name === 'tick') soundEngineRef.current.playTick();
      if(name === 'crane') soundEngineRef.current.playCrane();
      if(name === 'pop') soundEngineRef.current.playPop();
      if(name === 'win') soundEngineRef.current.playWin();
      if(name === 'lava') soundEngineRef.current.playLava();
    }
  }, [isMuted]);

  // Timer
  useEffect(() => {
    if (phase === 'playing' && gameState === 'waiting' && timeLeft > 0 && !hintText) { 
      timerRef.current = setTimeout(() => {
        setTimeLeft(prev => prev - 1);
        if (timeLeft <= 6) playSound('tick');
      }, 1000);
    } else if (timeLeft === 0 && gameState === 'waiting') {
      handleAnswer(null); 
    }
    return () => clearTimeout(timerRef.current);
  }, [timeLeft, phase, gameState, playSound, hintText]);

  // Logic: Crane Position
  const isCrowded = teams.length > 5;
  const updateCraneToActiveTeam = useCallback(() => {
     if (containerRef.current && teamRefs.current[currentTeamIndex]) {
        const containerRect = containerRef.current.getBoundingClientRect();
        const teamRect = teamRefs.current[currentTeamIndex].getBoundingClientRect();
        const relativeCenter = (teamRect.left - containerRect.left) + (teamRect.width / 2);
        const percent = (relativeCenter / containerRect.width) * 100;
        setCraneTarget(`${percent}%`);
     } else if (!isCrowded && teams.length > 0) {
       setCraneTarget(`${(currentTeamIndex * 100 / teams.length) + (100 / teams.length / 2)}%`);
     } else {
       setCraneTarget('50%');
     }
  }, [currentTeamIndex, isCrowded, teams.length]);

  // Scroll active team
  useEffect(() => {
    if (phase === 'playing' && isCrowded && teamRefs.current[currentTeamIndex]) {
        teamRefs.current[currentTeamIndex].scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'center' });
    }
  }, [currentTeamIndex, phase, isCrowded]);

  // GEMINI ACTIONS
  const handleGetHint = async () => {
    if (hintText) {
      setHintText(null); 
      return;
    }
    if (!currentWordObj) return;

    setIsHintLoading(true);
    const hint = await generateGeminiHint(currentWordObj.word);
    setHintText(hint);
    setIsHintLoading(false);
  };

  const handleTTS = async () => {
    if (!currentWordObj) return;
    setIsSpeaking(true);
    await playGeminiTTS(currentWordObj.word);
    setIsSpeaking(false);
  };


  // Setup Functions
  const startGame = () => {
    const players = playerInput.split(',').map(p => p.trim()).filter(p => p);
    if (gameMode === 'teams' && players.length < numTeams) return alert("Zu wenige Spieler fÃ¼r die Teams!");
    if (gameMode === 'ffa' && players.length < 2) return alert("Mindestens 2 Spieler!");

    // Helper to generate teams (internal)
    const availableNames = [...TEAM_NAMES].sort(() => 0.5 - Math.random());
    let newTeams = [];

    if (gameMode === 'ffa') {
       newTeams = players.map((p, i) => ({ id: i, name: p, members: [p], tower: [] }));
    } else {
       const shuffled = [...players].sort(() => 0.5 - Math.random());
       newTeams = Array(numTeams).fill(null).map((_, i) => ({ id: i, name: availableNames[i], members: [], tower: [] }));
       shuffled.forEach((p, i) => newTeams[i % numTeams].members.push(p));
    }

    setTeams(newTeams);
    usedWordsRef.current = [];
    setUsedCount(0);
    
    // Init first word
    const first = getUniqueWord([]);
    if(first) {
       usedWordsRef.current.push(first.word);
       setCurrentWordObj(first);
       setUsedCount(1);
    }
    
    setCurrentTeamIndex(0);
    setBlockVisualType('Neutral');
    setCraneTarget('50%');
    setPhase('playing');
  };

  const nextTurn = () => {
    setGameState('waiting');
    setFeedback(null);
    setHintText(null); 
    setTimeLeft(20);
    setBlockVisualType('Neutral');
    setShake(false);
    setCraneTarget('50%'); 

    const next = getUniqueWord(usedWordsRef.current);
    if (!next) {
       setPhase('summary');
       return;
    }
    usedWordsRef.current.push(next.word);
    setUsedCount(usedWordsRef.current.length);
    setCurrentWordObj(next);
    setCurrentTeamIndex(prev => (prev + 1) % teams.length);
  };

  const handleAnswer = (selectedType) => {
    clearTimeout(timerRef.current);
    setHintText(null); 
    
    if (selectedType === currentWordObj?.type) {
      playSound('correct');
      setFeedback('correct');
      setBlockVisualType(currentWordObj.type);
      setGameState('moving');
      playSound('crane');
      
      updateCraneToActiveTeam();

      setTimeout(() => {
        setGameState('dropping');
        
        // Wait for drop to complete (700ms)
        setTimeout(() => {
          // New Phase: Placing (Wait 200ms at bottom)
          setGameState('placing');
          
          setTimeout(() => {
            // Update Tower Data
            setTeams(prev => {
               const copy = [...prev];
               if(copy[currentTeamIndex]) copy[currentTeamIndex].tower.push(currentWordObj);
               return copy;
            });
            // Retract Crane
            setGameState('retracting');
            
            setTimeout(nextTurn, 800);
          }, 150); // Short placement pause
          
        }, 700);
      }, 1000);
    } else {
      playSound('wrong');
      setFeedback('wrong');
      setShake(true);
      setBlockVisualType('Verben');
      setGameState('exploding');
      
      // LAVA LEVEL PUNISHMENT
      if (theme === 'nether') {
         playSound('lava');
         setTimeout(() => {
            setTeams(prev => {
               const copy = [...prev];
               if (copy[currentTeamIndex] && copy[currentTeamIndex].tower.length > 0) {
                  // Remove top block
                  copy[currentTeamIndex].tower.pop();
               }
               return copy;
            });
         }, 800); // Slight delay for explosion to happen first
      }

      setTimeout(() => {
        setShake(false);
        nextTurn();
      }, 1500);
    }
  };

  return (
    <>
      <PixelFontStyles />
      {phase === 'setup' && (
        <SetupScreen 
          mode={gameMode} numTeams={numTeams} names={playerInput} isMuted={isMuted} theme={theme}
          onUpdateMode={setGameMode} onUpdateTeams={setNumTeams} onUpdateNames={setPlayerInput} onUpdateTheme={setTheme}
          toggleMute={() => setIsMuted(!isMuted)}
          onStart={startGame} 
        />
      )}
      
      {phase === 'playing' && (
        <GameScreen 
           teams={teams} currentTeamIndex={currentTeamIndex} currentWordObj={currentWordObj} 
           timeLeft={timeLeft} feedback={feedback} gameState={gameState} 
           craneTarget={craneTarget} blockVisualType={blockVisualType} usedCount={usedCount}
           isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)}
           onAnswer={handleAnswer} onRestart={() => setPhase('setup')}
           isCrowded={isCrowded} teamRefs={teamRefs} containerRef={containerRef} shake={shake}
           onGetHint={handleGetHint} hintText={hintText} isHintLoading={isHintLoading}
           onTTS={handleTTS} isSpeaking={isSpeaking}
           theme={theme}
        />
      )}

      {phase === 'summary' && (
        <SummaryScreen teams={teams} onRestart={() => setPhase('setup')} playSound={isMuted ? null : soundEngineRef.current} theme={theme} />
      )}
    </>
  );
}
