<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turmbau zu Wortarten</title>
    
    <!-- Tailwind CSS fÃ¼r das Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React und ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel zum Ãœbersetzen von JSX im Browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background-color: #333;
        }
        .font-pixel {
            font-family: 'VT323', monospace;
        }
        .pixel-border {
            box-shadow: 
                inset 2px 2px 0px rgba(255,255,255,0.4),
                inset -2px -2px 0px rgba(0,0,0,0.4);
        }
        /* 3D CUBE STYLES */
        .scene-container {
            perspective: 1000px;
            overflow: hidden;
        }
        .world {
            transform-style: preserve-3d;
            transform: rotateX(10deg);
            height: 100%;
        }
        .cube {
            position: relative;
            width: 100%;
            height: 48px;
            transform-style: preserve-3d;
            transition: transform 0.3s;
        }
        .face {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
        }
        .face.front {
            width: 100%;
            height: 48px;
            transform: translateZ(24px);
        }
        .face.top {
            width: 100%;
            height: 48px;
            transform: rotateX(90deg) translateZ(24px);
            filter: brightness(1.2);
        }
        .face.right {
            width: 48px;
            height: 48px;
            right: -24px;
            transform: rotateY(90deg) translateZ(24px); 
            filter: brightness(0.8);
            position: absolute; 
        }
        @keyframes floatCloud {
            0% { transform: translateX(100vw); }
            100% { transform: translateX(-200px); }
        }
        .mc-btn:active {
            transform: translateY(4px);
            box-shadow: 0px 0px 0px rgba(0,0,0,0.5) !important;
        }
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px) rotate(-1deg); }
            75% { transform: translateX(8px) rotate(1deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONS ---
        const IconBase = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Volume2 = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>;
        const VolumeX = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></IconBase>;
        const Users = (props) => <IconBase {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconBase>;
        const User = (props) => <IconBase {...props}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconBase>;
        const RefreshCcw = (props) => <IconBase {...props}><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></IconBase>;
        const Wand2 = (props) => <IconBase {...props}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></IconBase>;
        const Loader = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-6.219-2.56"/></IconBase>;

        // --- API KEY ---
        const apiKey = ""; 

        // --- GEMINI HELPERS ---
        const generateGeminiHint = async (word) => {
            if (!apiKey) return "Kein API Key verfÃ¼gbar.";
            const prompt = `Du bist ein lustiger Roboter in einem Lernspiel fÃ¼r Kinder. Gib einen kurzen, einfachen Hinweis zum deutschen Wort "${word}", damit das Kind erraten kann, ob es ein Nomen, Verb oder Adjektiv ist. Verrate NICHT die Wortart direkt und nenne NICHT das Wort selbst! Antworte mit maximal einem Satz.`;
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Konnte keinen Hinweis laden.";
            } catch (error) {
                return "Der Roboter schlÃ¤ft gerade...";
            }
        };

        const playGeminiTTS = async (text) => {
            if (!apiKey) return;
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                        }
                    })
                });
                const data = await response.json();
                const audioContent = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                if (audioContent) {
                    const binaryString = window.atob(audioContent);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = await ctx.decodeAudioData(bytes.buffer); 
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(ctx.destination);
                    source.start(0);
                }
            } catch (error) {}
        };

        // --- SOUNDS ---
        const createSoundEngine = () => {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return null;
            const ctx = new AudioContext();
            const playOsc = (freq, type, duration, startTime = 0, vol = 0.1) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, ctx.currentTime + startTime);
                gain.gain.setValueAtTime(vol, ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + startTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime + startTime);
                osc.stop(ctx.currentTime + startTime + duration);
            };
            return {
                playCorrect: () => { playOsc(987, 'square', 0.1, 0, 0.1); playOsc(1318, 'square', 0.3, 0.1, 0.1); },
                playWrong: () => { playOsc(150, 'sawtooth', 0.15, 0, 0.2); playOsc(100, 'sawtooth', 0.3, 0.1, 0.2); },
                playTick: () => playOsc(800, 'square', 0.05, 0, 0.05),
                playCrane: () => { playOsc(100, 'square', 0.1, 0, 0.05); playOsc(80, 'square', 0.1, 0.1, 0.05); },
                playPop: () => playOsc(400, 'square', 0.1, 0, 0.1),
                playLava: () => { playOsc(100, 'sawtooth', 0.5, 0, 0.1); playOsc(50, 'sawtooth', 0.5, 0.1, 0.1); },
                resume: () => { if (ctx.state === 'suspended') ctx.resume(); }
            };
        };

        // --- DATA ---
        const WORD_DATA = {
            Nomen: ["Auto", "Buch", "Essen", "Geld", "Geschenk", "Haus", "Jahr", "Kind", "Leben", "Licht", "Wasser", "Hund", "Schule", "Zeit", "Sonne", "Mutter", "Tisch"],
            Verben: ["laufen", "gehen", "springen", "lachen", "singen", "sprechen", "spielen", "essen", "trinken", "schlafen", "malen", "schreiben", "kochen"],
            Adjektive: ["alt", "jung", "neu", "bunt", "groÃŸ", "klein", "schnell", "langsam", "schÃ¶n", "hÃ¤sslich", "heiÃŸ", "kalt", "stark", "schwach", "traurig", "frÃ¶hlich"]
        };

        const TEAM_NAMES = ["Pixel-Piloten", "Block-Baumeister", "Crafting-Champions", "Voxel-Vulkane", "Redstone-Ritter"];

        const BLOCK_THEMES = {
            Nomen: { face: 'bg-[#3b82f6]', border: 'border-[#1d4ed8]', top: 'bg-[#60a5fa]', text: 'text-white' }, // Blau
            Verben: { face: 'bg-[#d12f2f]', border: 'border-[#8f1e1e]', top: 'bg-[#e85656]', text: 'text-white' }, // Rot
            Adjektive: { face: 'bg-[#2bba45]', border: 'border-[#1b7a2d]', top: 'bg-[#4cdb68]', text: 'text-white' }, // GrÃ¼n
            Neutral: { face: 'bg-[#b0b0b0]', border: 'border-[#7d7d7d]', top: 'bg-[#d1d1d1]', text: 'text-[#444]' }  // Grau
        };

        // --- HELPERS ---
        const getUniqueWord = (usedWordsList) => {
            const candidates = [];
            Object.keys(WORD_DATA).forEach(type => {
                WORD_DATA[type].forEach(word => { if (!usedWordsList.includes(word)) candidates.push({ word, type }); });
            });
            return candidates.length === 0 ? null : candidates[Math.floor(Math.random() * candidates.length)];
        };

        // --- COMPONENTS ---

        const Cube = ({ type, word, isCrane = false, gameState = 'waiting' }) => {
            // Logik: Am Kran ODER im Wartemodus (bevor Antwort gegeben wurde) ist der Block Grau
            const isNeutral = isCrane && (gameState === 'waiting' || gameState === 'dropping');
            const visualType = isNeutral ? 'Neutral' : type;
            const theme = BLOCK_THEMES[visualType];

            return (
                <div className="cube w-full">
                    <div className={`face front ${theme.face} border-4 ${theme.border} pixel-border flex items-center justify-center px-1`}>
                        <span className={`font-pixel font-bold uppercase text-center w-full ${theme.text} ${word.length > 10 ? 'text-lg' : 'text-2xl'}`}>{word}</span>
                    </div>
                    <div className={`face top ${theme.top} border-4 ${theme.border}`}></div>
                    {!isCrane && <div className={`face right ${theme.face} border-4 ${theme.border} w-[24px]`}></div>}
                </div>
            );
        };

        const MinecraftBackground = ({ theme = 'normal' }) => {
            const isNether = theme === 'nether';
            return (
                <div className={`absolute inset-0 z-0 overflow-hidden transition-colors duration-1000 ${isNether ? 'bg-[#2a0e0e]' : 'bg-[#87CEEB]'}`}>
                    {!isNether && (
                        <>
                            <div className="absolute top-10 right-10 w-24 h-24 bg-[#fff133] border-4 border-[#e6d82e] shadow-[8px_8px_0px_rgba(0,0,0,0.2)]"></div>
                            {[1, 2, 3].map(i => (
                                <div key={i} className="absolute h-16 bg-white opacity-80 border-4 border-white/50" 
                                    style={{ width: `${100 + i * 50}px`, top: `${i * 15}%`, animation: `floatCloud ${20 + i * 10}s linear infinite` }}></div>
                            ))}
                        </>
                    )}
                    <div className="absolute bottom-0 w-full h-32 z-10">
                        <div className={`w-full h-8 border-t-4 ${isNether ? 'bg-[#8B0000] border-[#5e0000]' : 'bg-[#5baf38] border-[#76d14d]'}`}></div>
                        <div className={`w-full h-full border-t-4 ${isNether ? 'bg-[#3b1e1e] border-[#291010]' : 'bg-[#8b5e3c] border-[#6d4a2f]'}`}></div>
                    </div>
                </div>
            );
        };

        const Crane3D = ({ xPosition, towerHeight, gameState, blockType, currentWord }) => {
            const isDropping = gameState === 'dropping';
            const isPlacing = gameState === 'placing'; 
            const isRetracting = gameState === 'retracting';
            if (gameState === 'exploding') return null;

            const pistonLength = `calc(100vh - ${288 + (towerHeight * 48)}px)`;

            return (
                <div className="absolute top-0 bottom-0 pointer-events-none z-30 transition-all duration-1000 ease-in-out" style={{ left: xPosition, transform: 'translateX(-50%)', width: '160px' }}>
                    <div className="absolute top-0 left-1/2 transform -translate-x-1/2 w-32 h-20 bg-[#9c9c9c] border-x-4 border-b-4 border-[#6e6e6e] z-30 flex flex-col items-center justify-center">
                        <div className="w-24 h-12 bg-[#b8b8b8] border-4 border-[#808080] flex items-center justify-center">
                            <div className="w-4 h-4 bg-red-500 animate-pulse"></div>
                        </div>
                    </div>
                    <div 
                        className="absolute top-20 left-1/2 transform -translate-x-1/2 w-8 bg-[#8f6d45] border-x-4 border-[#5c462c] flex flex-col items-center transition-all ease-linear"
                        style={{ height: (isDropping || isPlacing) ? pistonLength : '80px', transitionDuration: isDropping ? '700ms' : (isPlacing ? '0ms' : '700ms') }}
                    >
                        {!isRetracting && (
                            <div className="absolute bottom-0 transform translate-y-full w-40">
                                <div className="w-full h-4 bg-[#8b5e3c] border-4 border-[#5c462c] mb-[-4px] relative z-20"></div>
                                <div className="relative z-30 transform translate-y-2">
                                    <Cube type={blockType} word={currentWord} isCrane={true} gameState={gameState} />
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const SetupScreen = ({ onStart, onUpdateMode, onUpdateTeams, onUpdateNames, onUpdateTheme, mode, numTeams, names, theme, isMuted, toggleMute }) => (
            <div className={`min-h-screen flex items-center justify-center p-4 relative font-pixel transition-colors duration-500 ${theme === 'nether' ? 'bg-[#2a0e0e]' : 'bg-[#4a3b32]'}`}>
                <div className="max-w-3xl w-full bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] shadow-2xl relative z-10 p-2">
                    <div className={`p-8 text-center border-4 border-[#555] border-b-white border-r-white mb-4 ${theme === 'nether' ? 'bg-[#8b0000]' : 'bg-[#8b8b8b]'}`}>
                        <h1 className="text-6xl text-[#ffff55] drop-shadow-[4px_4px_0_#3f3f3f] uppercase mb-2">Turmbau</h1>
                        <div className="text-xl text-white uppercase tracking-widest">Wortarten Edition</div>
                    </div>
                    <div className="p-6 space-y-6">
                        <button onClick={toggleMute} className="absolute top-6 right-6 p-2 bg-[#c6c6c6] border-2 border-white border-b-[#555] border-r-[#555]">
                            {isMuted ? <VolumeX /> : <Volume2 />}
                        </button>
                        <div>
                            <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Welt</label>
                            <div className="flex gap-4">
                                <button onClick={() => onUpdateTheme('normal')} className={`flex-1 py-4 text-2xl uppercase border-4 mc-btn ${theme === 'normal' ? 'bg-[#5baf38] text-white' : 'bg-[#c6c6c6]'}`}>ðŸŒ² Gras</button>
                                <button onClick={() => onUpdateTheme('nether')} className={`flex-1 py-4 text-2xl uppercase border-4 mc-btn ${theme === 'nether' ? 'bg-[#d12f2f] text-white' : 'bg-[#c6c6c6]'}`}>ðŸ”¥ Lava</button>
                            </div>
                        </div>
                        <div>
                            <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Spielmodus</label>
                            <div className="flex gap-4">
                                <button onClick={() => onUpdateMode('teams')} className={`flex-1 py-4 text-2xl uppercase border-4 mc-btn ${mode === 'teams' ? 'bg-[#2a7fff] text-white' : 'bg-[#c6c6c6]'}`}>Teams</button>
                                <button onClick={() => onUpdateMode('ffa')} className={`flex-1 py-4 text-2xl uppercase border-4 mc-btn ${mode === 'ffa' ? 'bg-[#2a7fff] text-white' : 'bg-[#c6c6c6]'}`}>Solo</button>
                            </div>
                        </div>
                        {mode === 'teams' && (
                            <div>
                                <label className="block text-[#3f3f3f] text-2xl mb-2 uppercase">Anzahl Teams</label>
                                <div className="flex gap-2">
                                    {[2, 3, 4, 5].map(num => <button key={num} onClick={() => onUpdateTeams(num)} className={`flex-1 py-2 text-2xl border-4 mc-btn ${numTeams === num ? 'bg-[#ffff55]' : 'bg-[#c6c6c6]'}`}>{num}</button>)}
                                </div>
                            </div>
                        )}
                        <textarea value={names} onChange={(e) => onUpdateNames(e.target.value)} className="w-full p-4 bg-black text-white font-pixel text-xl border-4 border-[#7d7d7d]" rows={2} placeholder="Namen (Steve, Alex...)" />
                        <button onClick={onStart} className="w-full py-6 bg-[#5baf38] text-white text-4xl uppercase border-4 border-[#3c7a22] mc-btn">Spiel Starten</button>
                    </div>
                </div>
            </div>
        );

        const GameScreen = ({ teams, currentTeamIndex, currentWordObj, timeLeft, feedback, gameState, craneTarget, isMuted, toggleMute, onAnswer, onRestart, teamRefs, containerRef, shake, onGetHint, hintText, isHintLoading, onTTS, isSpeaking, theme }) => (
            <div className={`fixed inset-0 overflow-hidden font-pixel select-none ${shake ? 'animate-[shake_0.5s_ease-in-out_infinite]' : ''}`}>
                <MinecraftBackground theme={theme} />
                <div className="absolute top-0 w-full p-4 z-40 flex justify-between items-start">
                    <div className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 text-center shadow-lg">
                        <div className="text-gray-600 text-sm uppercase">Runde</div>
                        <div className="text-3xl text-black">{Math.floor(teams.reduce((acc, t) => acc + t.tower.length, 0) / teams.length) + 1}</div>
                    </div>
                    <div className={`border-4 border-white border-b-[#555] border-r-[#555] px-8 py-2 shadow-xl text-center ${theme === 'nether' ? 'bg-[#8b0000] text-white' : 'bg-[#c6c6c6] text-black'}`}>
                        <div className="text-xs uppercase">Am Zug</div>
                        <div className="text-3xl uppercase">{teams[currentTeamIndex].name}</div>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={onGetHint} disabled={isHintLoading || gameState !== 'waiting'} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 mc-btn"><Wand2 /></button>
                        <button onClick={onTTS} disabled={isSpeaking || gameState !== 'waiting'} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 mc-btn"><Volume2 /></button>
                        <button onClick={toggleMute} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 mc-btn">{isMuted ? <VolumeX /> : <Volume2 className="opacity-50" />}</button>
                        <button onClick={onRestart} className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 mc-btn"><RefreshCcw /></button>
                    </div>
                </div>

                <div className="flex-1 absolute inset-0 pt-32 pb-32 flex flex-col scene-container">
                    {hintText && (
                        <div className="absolute top-24 left-1/2 transform -translate-x-1/2 z-50 max-w-sm w-full p-4 animate-[popIn_0.4s]">
                            <div className="bg-white border-4 border-black p-4 shadow-2xl relative">
                                <div className="text-xl text-black">{hintText}</div>
                            </div>
                        </div>
                    )}
                    {currentWordObj && <Crane3D xPosition={craneTarget} towerHeight={teams[currentTeamIndex].tower.length} gameState={gameState} blockType={currentWordObj.type} currentWord={currentWordObj.word} />}
                    {feedback === 'correct' && <div className="absolute top-1/3 left-1/2 transform -translate-x-1/2 z-50 text-6xl text-[#ffff55] drop-shadow-2xl animate-bounce">RICHTIG!</div>}
                    <div ref={containerRef} className="flex-1 flex items-end px-8 z-10 w-full world justify-around">
                        {teams.map((team, idx) => (
                            <div key={team.id} ref={el => teamRefs.current[idx] = el} className="flex flex-col items-center justify-end h-full" style={{ width: `${100/teams.length}%` }}>
                                {idx === currentTeamIndex && <div className="animate-bounce mb-4 text-4xl text-[#ffff55]">â–¼</div>}
                                <div className="flex flex-col-reverse items-center w-full max-w-[140px]">
                                    <div className="w-full h-8 bg-[#222] border-4 border-black"></div>
                                    {team.tower.map((block, bIdx) => <Cube key={bIdx} type={block.type} word={block.word} />)}
                                </div>
                                <div className="mt-4 bg-[#b68962] border-4 border-[#5c4033] px-4 py-2 text-white uppercase text-sm">{team.name}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className={`absolute bottom-0 w-full border-t-8 border-black p-4 z-50 ${theme === 'nether' ? 'bg-[#2b0505]' : 'bg-[#333]'}`}>
                    <div className="absolute top-0 left-0 w-full h-4 bg-[#111]">
                        <div className={`h-full transition-all duration-1000 linear ${theme === 'nether' ? 'bg-orange-500' : 'bg-[#80ff20]'}`} style={{ width: `${(timeLeft / 20) * 100}%` }}></div>
                    </div>
                    <div className="max-w-4xl mx-auto flex gap-4 mt-4">
                        <div className="bg-[#c6c6c6] border-4 border-white border-b-[#555] border-r-[#555] p-2 min-w-[80px] flex items-center justify-center text-4xl">{timeLeft}</div>
                        {['Nomen', 'Verben', 'Adjektive'].map(type => (
                            <button key={type} onClick={() => onAnswer(type)} disabled={gameState !== 'waiting'} className={`flex-1 py-6 text-xl uppercase border-4 border-white border-b-[#555] border-r-[#555] mc-btn ${gameState === 'waiting' ? BLOCK_THEMES[type].face + ' ' + BLOCK_THEMES[type].text : 'bg-gray-400'}`}>
                                {type}
                            </button>
                        ))}
                    </div>
                </div>
            </div>
        );

        function App() {
            const [screen, setScreen] = useState('setup');
            const [mode, setMode] = useState('teams');
            const [numTeams, setNumTeams] = useState(2);
            const [names, setNames] = useState('');
            const [theme, setTheme] = useState('normal');
            const [isMuted, setIsMuted] = useState(false);
            const [teams, setTeams] = useState([]);
            const [currentTeamIndex, setCurrentTeamIndex] = useState(0);
            const [currentWordObj, setCurrentWordObj] = useState(null);
            const [timeLeft, setTimeLeft] = useState(20);
            const [gameState, setGameState] = useState('waiting');
            const [feedback, setFeedback] = useState(null);
            const [usedWords, setUsedWords] = useState([]);
            const [craneTarget, setCraneTarget] = useState('50%');
            const [hintText, setHintText] = useState(null);
            const [isHintLoading, setIsHintLoading] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);

            const soundEngine = useRef(null);
            const timerRef = useRef(null);
            const teamRefs = useRef([]);
            const containerRef = useRef(null);

            useEffect(() => { soundEngine.current = createSoundEngine(); }, []);

            const startGame = () => {
                soundEngine.current?.resume();
                const nameList = names.split(',').map(n => n.trim()).filter(n => n.length > 0);
                const finalTeams = [];
                if (mode === 'ffa') {
                    (nameList.length > 0 ? nameList : ["Spieler 1"]).forEach((p, i) => finalTeams.push({ id: i, name: p, tower: [] }));
                } else {
                    for(let i=0; i<numTeams; i++) finalTeams.push({ id: i, name: TEAM_NAMES[i % TEAM_NAMES.length], tower: [] });
                }
                setTeams(finalTeams);
                setScreen('game');
                setUsedWords([]);
                nextTurn(finalTeams, 0);
            };

            const nextTurn = (currentTeams, teamIdx) => {
                const wordObj = getUniqueWord(usedWords);
                if (!wordObj) { setScreen('setup'); return; }
                setFeedback(null);
                setCurrentWordObj(wordObj);
                setCurrentTeamIndex(teamIdx);
                setGameState('waiting');
                setTimeLeft(20);
                setHintText(null);
                updateCranePosition(teamIdx);
            };

            const updateCranePosition = (idx) => {
                setTimeout(() => {
                    const el = teamRefs.current[idx];
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        setCraneTarget(`${rect.left + rect.width / 2}px`);
                    }
                }, 100);
            };

            useEffect(() => {
                if (screen === 'game' && gameState === 'waiting') {
                    timerRef.current = setInterval(() => {
                        setTimeLeft(prev => {
                            if (prev <= 1) { handleAnswer('TIMEOUT'); return 20; }
                            if (prev <= 6 && !isMuted) soundEngine.current?.playTick();
                            return prev - 1;
                        });
                    }, 1000);
                }
                return () => clearInterval(timerRef.current);
            }, [screen, gameState, isMuted]);

            const handleAnswer = (selectedType) => {
                clearInterval(timerRef.current);
                const isCorrect = selectedType === currentWordObj.type;
                if (isCorrect) {
                    setGameState('dropping');
                    if (!isMuted) soundEngine.current?.playCrane();
                    setTimeout(() => {
                        setGameState('placing');
                        if (!isMuted) soundEngine.current?.playCorrect();
                        setFeedback('correct');
                        setTeams(prev => {
                            const newTeams = [...prev];
                            newTeams[currentTeamIndex].tower.push(currentWordObj);
                            return newTeams;
                        });
                        setTimeout(() => {
                            setGameState('retracting');
                            setTimeout(() => {
                                setUsedWords(prev => [...prev, currentWordObj.word]);
                                nextTurn(teams, (currentTeamIndex + 1) % teams.length);
                            }, 600);
                        }, 300);
                    }, 700);
                } else {
                    if (!isMuted) theme === 'nether' ? soundEngine.current?.playLava() : soundEngine.current?.playWrong();
                    setFeedback('wrong');
                    if (theme === 'nether' && teams[currentTeamIndex].tower.length > 0) {
                        setGameState('exploding');
                        setTimeout(() => {
                            setTeams(prev => {
                                const newTeams = [...prev];
                                newTeams[currentTeamIndex].tower.pop();
                                return newTeams;
                            });
                            nextTurn(teams, (currentTeamIndex + 1) % teams.length);
                        }, 800);
                    } else {
                        setTimeout(() => {
                            setUsedWords(prev => [...prev, currentWordObj.word]);
                            nextTurn(teams, (currentTeamIndex + 1) % teams.length);
                        }, 1000);
                    }
                }
            };

            return (
                <React.Fragment>
                    {screen === 'setup' ? (
                        <SetupScreen onStart={startGame} onUpdateMode={setMode} onUpdateTeams={setNumTeams} onUpdateNames={setNames} onUpdateTheme={setTheme} mode={mode} numTeams={numTeams} names={names} theme={theme} isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)} />
                    ) : (
                        <GameScreen teams={teams} currentTeamIndex={currentTeamIndex} currentWordObj={currentWordObj} timeLeft={timeLeft} feedback={feedback} gameState={gameState} craneTarget={craneTarget} isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)} onAnswer={handleAnswer} onRestart={() => setScreen('setup')} teamRefs={teamRefs} containerRef={containerRef} shake={feedback === 'wrong'} onGetHint={async () => { setIsHintLoading(true); setHintText(await generateGeminiHint(currentWordObj.word)); setIsHintLoading(false); }} hintText={hintText} isHintLoading={isHintLoading} onTTS={async () => { setIsSpeaking(true); await playGeminiTTS(currentWordObj.word); setIsSpeaking(false); }} isSpeaking={isSpeaking} theme={theme} />
                    )}
                </React.Fragment>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
